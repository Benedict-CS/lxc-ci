name: CI/CD Pipeline

on:
  push:
    branches:
      - main

env:
  REGISTRY_DOMAIN: registry.benedicttiong.site
  IMAGE_NAME: test-service
  API_HOST: 140.113.194.249 # 建議將此 IP 也放入 Secret
  DEVICE_ID: "test-1"

jobs:
  #====================================================
  # CI Job: Build and Push Docker Image (你的版本)
  #====================================================
  CI-Pipeline:
    name: CI-Pipeline
    runs-on: ubuntu-latest
    outputs:
      IMAGE_URL: ${{ steps.meta.outputs.IMAGE_URL }}
      IMAGE_TAG: ${{ steps.meta.outputs.IMAGE_TAG }}

    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Set up QEMU
        uses: docker/setup-qemu-action@v3

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
        
      - name: Generate Image Metadata
        id: meta
        run: |
          VERSION=$(date +%Y%m%d)-$(git rev-parse --short HEAD)
          echo "VERSION=$VERSION" >> $GITHUB_OUTPUT
          echo "IMAGE_URL=${{ env.REGISTRY_DOMAIN }}/${{ env.IMAGE_NAME }}" >> $GITHUB_OUTPUT
          echo "Generated Tag: $VERSION"

      - name: Build and Push Image
        uses: docker/build-push-action@v5
        with:
          context: .
          platforms: linux/arm64
          push: true
          tags: ${{ steps.meta.outputs.IMAGE_URL }}:${{ steps.meta.outputs.VERSION }}
          provenance: false

  你的觀察完全正確！

Log 清楚地顯示了 API_TOKEN=""，代表 ${{ steps.auth.outputs.TOKEN }} 這個表達式在後續步驟中被解析為空字串。這確實是目前 CI/CD 失敗的原因。

為什麼會這樣？

理論上，API_TOKEN="${{ steps.auth.outputs.TOKEN }}" 這種語法是 GitHub Actions 中跨步驟傳遞輸出的標準方法。它之所以會失敗，最可能的原因是：

Secrets 未設定：你在 Get Authentication Token 步驟中使用了 ${{ secrets.API_USER_EMAIL }} 和 ${{ secrets.API_USER_PASSWORD }}。如果你尚未在 GitHub Repo 的 Settings > Secrets and variables > Actions 中設定這兩個 Secrets，curl 指令會因為缺少帳號密碼而靜默失敗 (因為有 --silent 參數)，導致 TOKEN 變數為空。即使 log 印出了 "Successfully retrieved auth token."，實際的 TOKEN 可能是空的。

罕見的 Context 問題：極少數情況下，GitHub Actions 的 context (上下文) 可能會有傳遞問題。

你的提議：「直接用變數存不就好了？」

是的，這是一個非常好的替代方案！我們可以利用 GitHub Actions 提供的特殊檔案 GITHUB_ENV 來設定一個在後續所有步驟中都可用的環境變數。這比使用 outputs 更直接。

✅ 解決方案：使用 GITHUB_ENV
我們將修改 Get Authentication Token 步驟，讓它取得 Token 後，將其寫入 $GITHUB_ENV。後續步驟就可以像使用普通環境變數一樣直接使用 $API_TOKEN 了。

請用以下修正後的 CD-Pipeline job 替換你 YAML 檔案中的對應部分：

YAML

  #====================================================
  # CD Job: Deploy to Device via USP Controller
  #====================================================
  CD-Pipeline:
    name: CD-Pipeline
    needs: CI-Pipeline
    runs-on: ubuntu-latest

    steps:
      - name: 1. Get Authentication Token and Set Env Var
        id: auth
        run: |
          TOKEN=$(curl --location --request PUT 'http://${{ env.API_HOST }}/api/auth/login' \
            --header 'Content-Type: application/json' \
            --silent \
            --data-raw '{
                "email": "${{ secrets.API_USER_EMAIL }}",
                "password": "${{ secrets.API_USER_PASSWORD }}"
            }' | tr -d '"')
            
          # 檢查 TOKEN 是否為空
          if [ -z "$TOKEN" ]; then
            echo "::error::Failed to retrieve authentication token. Check secrets or API connectivity."
            exit 1
          fi
          
          echo "Successfully retrieved auth token."
          echo "::add-mask::$TOKEN" # 遮罩 Token
          
          # MODIFIED: 將 Token 寫入 GITHUB_ENV，使其成為後續步驟的環境變數
          echo "API_TOKEN=$TOKEN" >> $GITHUB_ENV 

      - name: 2. Uninstall All Existing Containers
        id: uninstall
        # REMOVED: 不再需要 env: API_TOKEN 或在 run 中重新賦值
        run: |
          # MODIFIED: 直接使用 $API_TOKEN 環境變數
          echo "--- Finding existing LXC instances on device: ${{ env.DEVICE_ID }} ---"
          
          INSTANCES=$(curl --location \
            --request PUT 'http://${{ env.API_HOST }}/api/device/${{ env.DEVICE_ID }}/stomp/get' \
            --header 'Content-Type: application/json' \
            --header "Authorization: ${API_TOKEN}" \
            --silent \
            --data-raw '{
                "param_paths": ["Device.LCM.LXC."],
                "max_depth": 1
            }' | jq -r '.req_path_results[0].resolved_path_results[].resolved_path')

          if [ -z "$INSTANCES" ]; then
            echo "No existing LXC instances found to uninstall. Skipping."
          else
            echo "Found instances to delete:"
            echo "$INSTANCES"
            
            for path in $INSTANCES; do
              echo "--- Deleting instance: $path ---"
              curl --location \
                --request PUT 'http://${{ env.API_HOST }}/api/device/${{ env.DEVICE_ID }}/stomp/del' \
                --header 'Content-Type: application/json' \
                --header "Authorization: ${API_TOKEN}" \
                --data-raw "{
                    \"allow_partial\": true,
                    \"obj_paths\": [\"$path\"]
                }"
              sleep 2
            done
          fi
          
          echo "--- Uninstall phase complete. Waiting for device to process... ---"
          sleep 10

      - name: 3. Install New Container
        id: install
        # REMOVED: 不再需要 env: API_TOKEN 或在 run 中重新賦值
        run: |
          # MODIFIED: 直接使用 $API_TOKEN 環境變數
          echo "--- Sending Add command to trigger new installation ---"
          
          RESPONSE=$(curl --location \
            --request PUT 'http://${{ env.API_HOST }}/api/device/${{ env.DEVICE_ID }}/stomp/add' \
            --header 'Content-Type: application/json' \
            --header "Authorization: ${API_TOKEN}" \
            --data-raw '{
                "allow_partial": true,
                "create_objs": [{
                    "obj_path": "Device.LCM.LXC."
                }]
            }')
          
          echo "Device response: $RESPONSE"
          
          if [[ "$RESPONSE" == *"OperSuccess"* ]]; then
            echo "Successfully triggered installation."
          else
            echo "Failed to trigger installation! Response was: $RESPONSE"
            exit 1
          fi
          
          echo "--- Installation triggered. Waiting for container to start... ---"
          sleep 60