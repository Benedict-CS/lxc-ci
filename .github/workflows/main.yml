# .github/workflows/main.yml
#
# 這是一個完整的 CI/CD 工作流程，它融合了程式碼品質檢查與自動化部署。
#
name: Build, Test, and Deploy mywebapp

# 觸發條件：
# 1. 當有新的程式碼被推送到 main 分支時 (例如合併 PR 後)
# 2. 當有新的 Pull Request 被建立或更新時
on:
  push:
    branches:
      - main
  pull_request:

# 方便管理的環境變數
env:
  REGISTRY_DOMAIN: registry.benedicttiong.site
  IMAGE_NAME: mywebapp

jobs:
  # --- JOB 1: 程式碼品質檢查 (Linting & Testing) ---
  lint-and-test:
    name: Code Quality Check
    runs-on: ubuntu-latest

    steps:
      - name: 1. Checkout repository
        uses: actions/checkout@v4

      - name: 2. Set up Python environment
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: 3. Install dependencies (linter)
        run: |
          python -m pip install --upgrade pip
          pip install flake8

      - name: 4. Lint with flake8
        run: |
          flake8 . --count --select=E9,F63,F7,F82 --show-source --statistics

  # --- JOB 2: 建構並推送映像檔 ---
  build-and-push:
    name: Build and Push Docker Image
    needs: lint-and-test # 必須等待上一個 job 成功
    runs-on: ubuntu-latest

    if: github.event_name == 'push' && github.ref == 'refs/heads/main'

    outputs:
      VERSION: ${{ steps.vars.outputs.VERSION }}
      IMAGE_URL: ${{ steps.vars.outputs.IMAGE_URL }}

    steps:
      - name: 1. Checkout Code
        uses: actions/checkout@v4

      - name: 2. Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: 3. Generate Version and Image URL
        id: vars
        run: |
          VERSION=$(date +%Y%m%d)-$(git rev-parse --short HEAD)
          echo "VERSION=$VERSION" >> $GITHUB_OUTPUT
          IMAGE_URL="${{ env.REGISTRY_DOMAIN }}/${{ env.IMAGE_NAME }}:$VERSION"
          echo "IMAGE_URL=$IMAGE_URL" >> $GITHUB_OUTPUT

      - name: 4. Update Version in app.py
        run: |
          sed -i "s/VERSION = .*/VERSION = \"${{ steps.vars.outputs.VERSION }}\"/" app.py

      - name: 5. Build and Push to Private Registry
        run: |
          docker buildx build --platform linux/arm64 -t ${{ steps.vars.outputs.IMAGE_URL }} --push .

      # --- 新增的驗證步驟 ---
      - name: 6. Verify Push to Registry
        run: |
          echo "Verifying that image ${{ steps.vars.outputs.IMAGE_URL }} exists in registry..."
          # 稍作等待，確保 registry API 已更新
          sleep 5
          # 使用 curl 查詢 registry 的 catalog API，並用 grep 確認我們的映像檔名稱是否存在
          # 如果 grep 找不到，指令會失敗，整個 job 也會失敗
          curl -s https://${{ env.REGISTRY_DOMAIN }}/v2/_catalog | grep '"${{ env.IMAGE_NAME }}"'

  # --- JOB 3: 部署到 prplOS (使用手動 SSH) ---
  deploy-to-prplos:
    name: Deploy to prplOS
    needs: build-and-push
    runs-on: ubuntu-latest

    if: github.event_name == 'push' && github.ref == 'refs/heads/main'

    steps:
      - name: 1. Install SSH client
        run: sudo apt-get update && sudo apt-get install -y sshpass

      - name: 2. Deploy via Manual SSH
        env:
          host: 140.113.194.231
          username: root
          password: winlabisgood # 改用密碼登入
          port: 670 # 改用你指定的埠號
          IMAGE_URL: ${{ needs.build-and-push.outputs.IMAGE_URL }}
          VERSION: ${{ needs.build-and-push.outputs.VERSION }}
          # *** 新增：Nginx 伺服器的內部 IP ***
          NGINX_INTERNAL_IP: 192.168.1.242
          REGISTRY_DOMAIN: ${{ env.REGISTRY_DOMAIN }}
        run: |
          # 準備要執行的遠端指令
          REMOTE_SCRIPT="
          echo '--- Modifying hosts file for NAT loopback workaround ---';
          # 備份 hosts 檔案
          cp /etc/hosts /etc/hosts.bak;
          # 移除舊的記錄 (以防上次執行失敗)
          sed -i '/${REGISTRY_DOMAIN}/d' /etc/hosts;
          # 新增一筆記錄，將你的網域指向 Nginx 的內部 IP
          echo '${NGINX_INTERNAL_IP} ${REGISTRY_DOMAIN}' >> /etc/hosts;
          echo 'Current hosts file:';
          cat /etc/hosts;

          echo '--- Installing new container ---';
          RND=\$(cat /proc/sys/kernel/random/uuid);
          UUID_V5=\$(echo \"\$RND\" | sed -E 's/^(.{14}).(.*)\$/\\\\15\\\\2/');
          ubus-cli 'SoftwareModules.InstallDU(URL=\"docker://${IMAGE_URL}\", UUID=\"'\$UUID_V5'\", ExecutionEnvRef=\"generic\", NetworkConfig={ \"AccessInterfaces\" = [{\"Reference\" = \"Lan\"}] }, \"Privileged\"=true)';
          
          echo '--- Restoring hosts file ---';
          # 還原 hosts 檔案
          mv /etc/hosts.bak /etc/hosts;

          echo \"Deployment of version ${VERSION} initiated.\";
          "

          # 使用 sshpass 執行指令
          echo "Connecting to ${SSH_USER}@${SSH_HOST} on port 670..."
          sshpass -p "${SSH_PASS}" ssh -o StrictHostKeyChecking=no -p 670 "${SSH_USER}@${SSH_HOST}" "${REMOTE_SCRIPT}"




